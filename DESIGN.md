### 1) Общая цель проекта

Цель проекта — разработать API Gateway, который контролирует и ограничивает входящий трафик от клиентов, предотвращая перегрузки системы. Мы хотим реализовать гибкий механизм rate limiting с настройками по регионам, IP, user-agent и другими фильтрами. Проект должен быть отказоустойчивым, наглядным и управляемым через админ-панель. 

Отдельное внимание уделяется админ-панели, которая позволит:

-в реальном времени наблюдать за текущей нагрузкой через Dashboard;
-просматривать логи отказов и превышений лимитов;
-управлять параметрами ограничений без необходимости перезапуска системы.


### 2) Сценарии использования

Сценарий №1: Защита API от DDoS/спам-запросов

Клиент или бот начинает отправлять слишком много запросов в API. Gateway определяет превышение лимита по IP/региону и начинает возвращать 429 Too Many Requests, не нагружая backend. Логируется событие, и в админке можно наблюдать всплеск.

Сценарий №2: Гибкая настройка лимитов

Администратор замечает в логах, что пользователи из определённого региона перегружают систему. Через интерфейс Limit Admin он снижает лимиты для этого региона — без перезапуска Gateway.

Сценарий №3: Тестирование под нагрузкой

Разработчик запускает Load Simulator, чтобы проверить поведение системы при 500 rps. На Dashboard отображается рост нагрузки, видно количество отклонённых запросов. Можно проверить, как включается Circuit Breaker или Retry Logic.



### 3) Архитектура и компоненты

1. Load Simulator
Отвечает за генерацию нагрузки на систему. Используется для тестирования поведения API Gateway в условиях высокой частоты запросов.
Передаёт: HTTP-запросы
Получает: HTTP-ответы (200, 429, 503)

2. API Gateway
Основная точка входа в систему. Выполняет проверку лимитов, применяет Retry Logic и Circuit Breaker. Обрабатывает запрос и возвращает ответ.
Источник лимитов: Redis через Rate Limit Config
Передаёт: метрики, логи → Logging

3. Rate Limit Config
Компонент, который управляет правилами ограничения частоты: лимиты по региону, IP, user-agent и т.д. Может быть обновлён в реальном времени через админку.
Работает с Redis (чтение/запись конфигурации)

4. Redis
Хранилище счётчиков лимитов и настроек. Используется API Gateway для хранения текущего состояния запросов.
Быстрые операции:
-Увеличение счётчиков запросов
-Автоматическое удаление устаревших данных

5. Logging + Metrics
Сервис для сбора логов и метрик по запросам.
Получает данные от API Gateway
Передаёт их в MonitoringService

6. MonitoringService
Отвечает за агрегацию и представление данных: логов, лимитов и нагрузки.
REST API для frontend
Позволяет CRUD для лимитов и просмотр логов

7. Frontend
Пользовательский интерфейс для администратора.
Показывает Dashboard, Log Viewer, Limit Admin
Работает с MonitoringService по API


### 4) В рамках MVP будет реализовано:

1. Load Simulator — простая программа, которая имитирует клиентов и отправляет много запросов на API Gateway.
Можно настроить:
-сколько запросов в секунду отправлять (RPS);
-как долго слать запросы (время);
-регион

2. API Gateway, обрабатывающий входящие запросы с применением:
-Rate Limiting (по заданным фильтрам из конфига);
-2 стартегии лимитирования
-Circuit Breaker (по таймаутам/ошибкам);
-Retry Logic (попытка повтора при сбоях);

3. Гибкая настройка лимитов через JSON-конфиг с фильтрами (регион, IP, user-agent);

4. Redis — для хранения счётчиков и конфигурации;

5. Logging и метрики — хранение событий превышения лимитов и сбоев в файле(последние 1000);

6. MonitoringService — REST API для получения логов, лимитов, метрик; CRUD для конфига лимитов;

7. Frontend (Admin Panel) на React:
-Dashboard с графиком запросов(будем собирать данные из конфигов и строить графики);
-Log Viewer (таблица логов с фильтрацией);
-Rate Limit Admin (редактирование лимитов);

8. Архитектурная схема + понятная документация (README.md, DESIGN.md);

9. Демо-сценарий: "как нагрузка растёт и система её режет" с отображением в UI.



### 5) Максимальный функционал

- Балансировщик запросов между несколькими API Gateway.
- Реальный backend-сервис с бизнес-логикой (полезная нагрузка).
- Реализую отказоустойчивость: проверка отказов, health-check, репликация Redis.
- Адаптивные лимиты — повышение/понижение лимита на основе нагрузки;
- Prometheus + Grafana — продвинутая метрика и визуализация;
- Поднимем БД для логов и метрик
- 4 стратегии лимитирования


### 6) Выбор технологий и обоснование

1. Язык и фреймворк:
.NET 8 / ASP.NET Core — современная, мощная платформа с поддержкой Middleware, DelegatingHandler, хорошей производительностью и удобной работой с REST API. Подходит для написания Gateway и всех вспомогательных сервисов.

2. Frontend:
React — популярная и гибкая библиотека для создания интерфейсов. Позволяет быстро реализовать Dashboard, Log Viewer и админку лимитов. Большое количество библиотек для графиков и визуализации.

3. База данных (временно):
Redis — быстрая in-memory база, идеально подходящая для хранения временных счётчиков запросов и конфигурации лимитов. Обеспечивает миллисекундный доступ.

4. Логирование:
Serilog — удобная и расширяемая библиотека логирования для .NET, подходит для сбора и фильтрации логов в API Gateway.

5. Симулятор нагрузки:
.NET Console App — простая консольная программа, запускаемая с параметрами (RPS, продолжительность, регион). Можно быстро собрать и кастомизировать под себя.

6. Сбор и визуализация метрик (в перспективе):
Prometheus + Grafana (Nice-to-have) — мощный стек мониторинга, используется в продакшене, может быть добавлен позже для анализа метрик.

7. Формат конфигурации:
JSON — простой формат для хранения и передачи лимитов, легко редактируется вручную или через UI.


### 7) Конкретная реализация

1. Load Simulator
Как реализуем:
-Консольное приложение на .NET 8.
-Принимает аргументы командной строки: --rps, --duration, --region.
-Использует HttpClient с Parallel.ForEachAsync для генерации параллельных запросов.
-Записывает метрики (сколько запросов отправлено, сколько получено 200/429/503 и т.д.) в консоль или файл.

Почему:
Легко запускать, быстро писать, можно кастомизировать под нужды тестирования.

Связь:
Бьёт запросами в API Gateway, получает обратно HTTP-ответы.

2. API Gateway
Как реализуем:
-ASP.NET Core Web API.
-Входящие запросы обрабатываются через собственный RateLimitingMiddleware.
-В Middleware проверяется лимит (по IP/региону и т.д.) — если превышен, возвращается 429.
-Если лимит не превышен, запрос либо обрабатывается на месте, либо проксируется дальше через HttpClient + DelegatingHandler

Встроено логирование через Serilog и метрики по каждому запросу.

Почему:
Middleware — это гибкий и простой способ встроиться в обработку запросов до контроллера. Позволяет централизованно применять лимиты, логику отказа, ретраи и т.д.

Связь:
Читает лимиты и состояние из Redis → пишет логи в LoggingService → отдаёт ответ симулятору.

3. Rate Limit Config
Как реализуем:
-Первоначально лимиты задаются в JSON-файле.
-При старте сервиса конфигурация загружается и записывается в Redis.
-Каждый лимит хранится как отдельный ключ в Redis.
-MonitoringService имеет REST API для обновления этих лимитов в Redis.

Почему:
Redis позволяет быстро получать и изменять настройки без перезапуска сервиса. Это также даёт гибкость при редактировании через UI.

Связь:
Конфиг читается API Gateway, обновляется через MonitoringService.

4. Redis
Как реализуем:
-Используем ключи для счётчиков.
-Увеличиваем их с помощью команды INCR.
-Устанавливаем срок действия ключа через EXPIRE, чтобы он сбрасывался автоматически.

Почему:
Redis — самый быстрый способ работать с лимитами. Он in-memory, работает миллисекунды.

Связь:
Используется API Gateway для лимитов и MonitoringService для статистики.

5. Logging & Metrics
Как реализуем:
-Используем Serilog в API Gateway.
-Пишем логи в файл или в PostgreSQL(в продвинутой версии).
-Лог включает: время, IP, регион, URL, статус ответа, причина отказа, задержка и т.д.
-MonitoringService может читать этот файл и отдвать на UI

Почему:
Serilog удобен, гибок и хорошо настраивается на разные логи (ошибки, успехи, отказы).

Связь:
API Gateway пишет в лог → MonitoringService читает → UI отображает.

6. MonitoringService(REST API)
Как реализуем:
-ASP.NET Core Web API с 3 основными группами эндпоинтов:
/logs — получить логи;
/metrics — получить текущую статистику (RPS, процент отказов);
/limits — получить и изменить лимиты.
Чтение логов: либо из файла, либо (в будущем) из базы.
-CRUD лимитов.
-конфигурируем метрики из логов

Почему:
Это “backend” для админки, всё централизовано. Позволяет отделить UI от логики.

Связь:
Получает данные из Redis и Logging, отдаёт их Frontend’у через REST.


7. Frontend (Admin Panel)
Как реализуем:
React-приложение с компонентами:
-Dashboard (графики);
-Log Viewer (таблица логов);
-Limit Admin (редактирование лимитов).

Почему:
React даёт гибкость и скорость при разработке UI. Библиотеки типа recharts позволяют быстро рисовать метрики.

Связь:
Работает с MonitoringService по REST. Не обращается напрямую к Redis или API Gateway.


### 8) Расширяемость

- IRateLimitingStrategy — интерфейс для новых стратегий
- IRateLimitStore — абстракция над Redis
- Лёгкое добавление аутентификации клиентов (JWT, API Key) (в продвинутой версии)
- Плагинная Middleware-архитектура

### 9) Тестирование

Unit-тесты:
- Rate Limiting
- Circuit Breaker
- Retry Logic
- Интеграционные тесты симуляции нагрузки
- Стресс-тесты (до 10.000 RPS)

### 10) Безопасность и защита (в продвинутой версии)

- Авторизация в админке (JWT + роли)
- Валидация данных на всех слоях
- HTTPS-only
- Доступ к REST API только для авторизованных клиентов

### 11) CI/CD и деплой

- docker-compose.yml для Redis + Gateway + Monitoring
- README с инструкцией запуска

### 12) Документация

- README.md с запуском, архитектурой и сценариями
- DESIGN.md с подробностями по архитектуре, конфигам, логике








